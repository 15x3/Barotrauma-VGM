<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Редактор XML игровых предметов - Пакетный вывод</title>
    <style>
        body { font-family: 'Inter', sans-serif; margin: 20px; background-color: #f0f2f5; color: #333; }
        h1, h2, h3 { color: #0056b3; }
        .container {
            display: flex;
            flex-direction: row;
            gap: 25px;
            max-width: 1800px; /* Увеличить максимальную ширину для двух колонок */
            margin: 0 auto;
        }
        .left-column, .right-column {
            flex: 1; /* Обе колонки распределяют ширину поровну */
        }
        .section-panel {
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin-bottom: 25px; /* Добавить отступы */
        }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; }
        input[type="text"], input[type="number"], textarea, select {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease, transform 0.1s ease;
            margin-right: 10px;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        button:hover { background-color: #0056b3; transform: translateY(-1px); }
        button:active { transform: translateY(0); }
        button.active { background-color: #28a745; } /* Кнопка активного режима */
        button.coordinate-picker-btn {
            background-color: #6c757d;
            padding: 5px 10px;
            font-size: 0.9em;
            margin-left: 5px;
        }
        button.coordinate-picker-btn:hover { background-color: #5a6268; }

        canvas {
            border: 2px dashed #007bff;
            background-color: #e9ecef;
            display: block;
            margin-top: 15px;
            width: 800px; /* Фиксированная ширина холста */
            height: 600px; /* Фиксированная высота холста */
            cursor: grab; /* Курсор по умолчанию */
            border-radius: 8px;
        }
        canvas.grabbing {
            cursor: grabbing; /* Курсор захвата при перетаскивании */
        }
        pre {
            background-color: #e9ecef;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 8px;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 200px;
            overflow-x: auto;
        }
        .mode-buttons button { width: auto; }
        .attribute-group {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            background-color: #fdfdfd;
        }
        .attribute-group h4 {
            margin-top: 0;
            color: #007bff;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .dynamic-item-group {
            border: 1px dashed #ccc;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            position: relative;
        }
        .dynamic-item-group .remove-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 3px 8px;
            cursor: pointer;
            font-size: 0.8em;
        }
        .dynamic-item-group .remove-btn:hover {
            background-color: #c82333;
        }
        .dynamic-item-group label, .dynamic-item-group input, .dynamic-item-group select {
            width: auto;
            display: inline-block;
            margin-right: 10px;
            margin-bottom: 5px;
        }
        .dynamic-item-group input[type="text"], .dynamic-item-group input[type="number"] {
            width: 120px; /* Сделать динамические поля ввода меньше */
        }
        .dynamic-item-group input[type="checkbox"] {
            width: auto;
        }
        .sub-container-group {
            border: 1px solid #a7d9ff;
            background-color: #e6f7ff;
            padding: 15px;
            margin-top: 15px;
            border-radius: 8px;
            position: relative;
        }
        .sub-container-group .remove-btn {
            background-color: #ff4d4f;
        }
        .slot-icon-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        .slot-icon-group > div {
            flex: 1 1 calc(50% - 10px); /* Две колонки */
            min-width: 250px;
        }
        .slot-icon-group label input {
            width: calc(100% - 10px);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-column">
            <div class="section-panel">
                <h2>Основная информация о предмете (Атрибуты предмета)</h2>

                <div class="attribute-group">
                    <h4>Основные идентификаторы и имя</h4>
                    <label for="itemIdentifier">Идентификатор: <small>(Обязательно)</small></label>
                    <input type="text" id="itemIdentifier" value="newweapon">

                    <label for="itemName">Имя:</label>
                    <input type="text" id="itemName" value="Новое Оружие">

                    <label for="tags">Теги (разделенные запятыми):</label>
                    <input type="text" id="tags" value="smallitem,weapon">

                    <label for="itemCategory">Категория:</label>
                    <select id="itemCategory">
                        <option value="Weapon">Оружие</option>
                        <option value="Decorative">Декоративный</option>
                        <option value="Machine">Машина</option>
                        <option value="Medical">Медицинский</option>
                        <option value="Diving">Дайвинг</option>
                        <option value="Equipment">Оборудование</option>
                        <option value="Fuel">Топливо</option>
                        <option value="Electrical">Электрический</option>
                        <option value="Material">Материал</option>
                        <option value="Alien">Инопланетный</option>
                        <option value="Wrecked">Разрушенный</option>
                        <option value="Misc">Разное</option>
                    </select>
                    <label for="subcategory">Подкатегория:</label>
                    <input type="text" id="subcategory" placeholder="напр., ЛегкоеОружие">
                    <label for="impactSoundTag">Тег звука удара:</label>
                    <input type="text" id="impactSoundTag" value="impact_metal_light">
                    <label for="itemScale">Общий масштаб предмета: <small>(число, уровень предмета)</small></label>
                    <input type="number" id="itemScale" step="0.01" value="1.0">
                </div>

                <div class="attribute-group">
                    <h4>Атрибуты взаимодействия и визуальные</h4>
                    <label for="interactDistance">Расстояние взаимодействия: <small>(число)</small></label>
                    <input type="number" id="interactDistance" step="0.1" value="50">
                    <label for="interactPriority">Приоритет взаимодействия: <small>(число)</small></label>
                    <input type="number" id="interactPriority" step="0.1" value="1.0">
                    <label for="interactThroughWalls">Взаимодействие сквозь стены: <small>(булево)</small></label>
                    <select id="interactThroughWalls">
                        <option value="false">false</option>
                        <option value="true">true</option>
                    </select>
                    <label for="focusOnSelected">Фокусироваться на выбранном: <small>(булево)</small></label>
                    <select id="focusOnSelected">
                        <option value="false">false</option>
                        <option value="true">true</option>
                    </select>
                    <label for="offsetOnSelected">Смещение при выборе: <small>(число)</small></label>
                    <input type="number" id="offsetOnSelected" step="1" value="0">
                    <label for="showContentsInTooltip">Показывать содержимое во всплывающей подсказке: <small>(булево)</small></label>
                    <select id="showContentsInTooltip">
                        <option value="false">false</option>
                        <option value="true">true</option>
                    </select>
                    <label for="spriteColor">Цвет спрайта: <small>(R,G,B,A напр.: 1.0,1.0,1.0,1.0)</small></label>
                    <input type="text" id="spriteColor" value="1.0,1.0,1.0,1.0">
                </div>

                <div class="attribute-group">
                    <h4>Статус и здоровье</h4>
                    <label for="health">Здоровье: <small>(число)</small></label>
                    <input type="number" id="health" step="1" value="100">
                    <label for="indestructible">Неразрушимый: <small>(булево)</small></label>
                    <select id="indestructible">
                        <option value="false">false</option>
                        <option value="true">true</option>
                    </select>
                    <label for="fireProof">Огнеупорный: <small>(булево)</small></label>
                    <select id="fireProof">
                        <option value="false">false</option>
                        <option value="true">true</option>
                    </select>
                    <label for="waterProof">Водонепроницаемый: <small>(булево)</small></label>
                    <select id="waterProof">
                        <option value="false">false</option>
                        <option value="true">true</option>
                    </select>
                    <label for="impactTolerance">Ударостойкость: <small>(число)</small></label>
                    <input type="number" id="impactTolerance" step="0.1" value="10.0">
                </div>

                <div class="attribute-group">
                    <h4>Другие атрибуты</h4>
                    <label for="maxStackSize">Максимальный размер стака:</label>
                    <input type="number" id="maxStackSize" value="1">
                    <label for="allowAsExtraCargo">Разрешить как дополнительный груз: <small>(булево)</small></label>
                    <select id="allowAsExtraCargo">
                        <option value="false">false</option>
                        <option value="true">true</option>
                    </select>
                    <label for="cargoContainerIdentifier">Идентификатор грузового контейнера: <small>(строка)</small></label>
                    <input type="text" id="cargoContainerIdentifier" placeholder="metalcrate">
                    <label for="allowRotatingInEditor">Разрешить вращение в редакторе: <small>(булево)</small></label>
                    <select id="allowRotatingInEditor">
                        <option value="true">true</option>
                        <option value="false">false</option>
                    </select>
                    <label for="linkable">Соединяемый: <small>(булево)</small></label>
                    <select id="linkable">
                        <option value="false">false</option>
                        <option value="true">true</option>
                    </select>
                </div>
                <div class="attribute-group">
                    <h4>Цена</h4>
                    <label for="basePrice">Базовая цена:</label>
                    <input type="number" id="basePrice" value="666">
                    <div id="dynamicPrices">
                        <div class="dynamic-item-group">
                            <button type="button" class="remove-btn" onclick="this.parentElement.remove()">Удалить</button>
                            <label>Идентификатор магазина: <input type="text" class="price-storeidentifier" value="merchantoutpost"></label>
                            <label>Продается: <select class="price-sold"><option value="false">false</option><option value="true">true</option></select></label>
                            <label>Множитель: <input type="number" class="price-multiplier" step="0.01" value="1.5"></label>
                            <label>Мин. доступность: <input type="number" class="price-minavailable" value=""></label>
                        </div>
                        <div class="dynamic-item-group">
                            <button type="button" class="remove-btn" onclick="this.parentElement.remove()">Удалить</button>
                            <label>Идентификатор магазина: <input type="text" class="price-storeidentifier" value="merchantcity"></label>
                            <label>Продается: <select class="price-sold"><option value="false">false</option><option value="true">true</option></select></label>
                            <label>Множитель: <input type="number" class="price-multiplier" step="0.01" value="1.25"></label>
                            <label>Мин. доступность: <input type="number" class="price-minavailable" value="1"></label>
                        </div>
                        <div class="dynamic-item-group">
                            <button type="button" class="remove-btn" onclick="this.parentElement.remove()">Удалить</button>
                            <label>Идентификатор магазина: <input type="text" class="price-storeidentifier" value="merchantresearch"></label>
                            <label>Продается: <select class="price-sold"><option value="false">false</option><option value="true">true</option></select></label>
                            <label>Множитель: <input type="number" class="price-multiplier" step="0.01" value="1.25"></label>
                            <label>Мин. доступность: <input type="number" class="price-minavailable" value=""></label>
                        </div>
                        <div class="dynamic-item-group">
                            <button type="button" class="remove-btn" onclick="this.parentElement.remove()">Удалить</button>
                            <label>Идентификатор магазина: <input type="text" class="price-storeidentifier" value="merchantmilitary"></label>
                            <label>Продается: <select class="price-sold"><option value="false">false</option><option value="true">true</option></select></label>
                            <label>Множитель: <input type="number" class="price-multiplier" step="0.01" value="0.9"></label>
                            <label>Мин. доступность: <input type="number" class="price-minavailable" value="1"></label>
                        </div>
                        <div class="dynamic-item-group">
                            <button type="button" class="remove-btn" onclick="this.parentElement.remove()">Удалить</button>
                            <label>Идентификатор магазина: <input type="text" class="price-storeidentifier" value="merchantmine"></label>
                            <label>Продается: <select class="price-sold"><option value="false">false</option><option value="true">true</option></select></label>
                            <label>Множитель: <input type="number" class="price-multiplier" step="0.01" value="1.25"></label>
                            <label>Мин. доступность: <input type="number" class="price-minavailable" value=""></label>
                        </div>
                        <div class="dynamic-item-group">
                            <button type="button" class="remove-btn" onclick="this.parentElement.remove()">Удалить</button>
                            <label>Идентификатор магазина: <input type="text" class="price-storeidentifier" value="merchantarmory"></label>
                            <label>Продается: <select class="price-sold"><option value="false">false</option><option value="true">true</option></select></label>
                            <label>Множитель: <input type="number" class="price-multiplier" step="0.01" value="0.9"></label>
                            <label>Мин. доступность: <input type="number" class="price-minavailable" value="1"></label>
                        </div>
                    </div>
                    <button type="button" onclick="addPrice()">Добавить еще правила цены</button>
                </div>
                
                <div class="attribute-group">
                    <h4>Предпочитаемый контейнер</h4>
                    <div id="dynamicPreferredContainers">
                        </div>
                    <button type="button" onclick="addPreferredContainer()">Добавить предпочитаемый контейнер</button>
                </div>

                <div class="attribute-group">
                    <h4>Изготовление</h4>
                    <label for="fabricateTime">Требуемое время:</label>
                    <input type="number" id="fabricateTime" value="35">
                    <label for="fabricateSuitableFabricators">Подходящие фабрикаторы (разделенные запятыми):</label>
                    <input type="text" id="fabricateSuitableFabricators" value="fabricatorVGM">
                    <div id="dynamicFabricateRequiredItems">
                        <div class="dynamic-item-group">
                            <button type="button" class="remove-btn" onclick="this.parentElement.remove()">Удалить</button>
                            <label>Идентификатор предмета: <input type="text" class="fabricate-item-identifier" value="assaultrifle"></label>
                            <label>Количество: <input type="number" class="fabricate-item-amount" value="1"></label>
                            <label>Мин. состояние (-1 для игнорирования): <input type="number" class="fabricate-mincondition" step="0.01" value="0"></label>
                        </div>
                        <div class="dynamic-item-group">
                            <button type="button" class="remove-btn" onclick="this.parentElement.remove()">Удалить</button>
                            <label>Идентификатор предмета: <input type="text" class="fabricate-item-identifier" value="steel"></label>
                            <label>Количество: <input type="number" class="fabricate-item-amount" value="3"></label>
                            <label>Мин. состояние (-1 для игнорирования): <input type="number" class="fabricate-mincondition" step="0.01" value="0"></label>
                        </div>
                    </div>
                    <button type="button" onclick="addFabricateRequiredItem()">Добавить материал для изготовления</button>
                </div>

                <div class="attribute-group">
                    <h4>Демонтаж</h4>
                    <label for="deconstructTime">Время:</label>
                    <input type="number" id="deconstructTime" value="10">
                    <div id="dynamicDeconstructItems">
                        <div class="dynamic-item-group">
                            <button type="button" class="remove-btn" onclick="this.parentElement.remove()">Удалить</button>
                            <label>Идентификатор предмета: <input type="text" class="deconstruct-item-identifier" value="plastic"></label>
                        </div>
                        <div class="dynamic-item-group">
                            <button type="button" class="remove-btn" onclick="this.parentElement.remove()">Удалить</button>
                            <label>Идентификатор предмета: <input type="text" class="deconstruct-item-identifier" value="titaniumaluminiumalloy"></label>
                        </div>
                    </div>
                    <button type="button" onclick="addDeconstructItem()">Добавить продукт демонтажа</button>
                </div>

                <div class="attribute-group">
                    <h4>Физическое тело</h4>
                    <label for="bodyWidth">Ширина:</label>
                    <input type="number" id="bodyWidth" value="160">
                    <label for="bodyHeight">Высота:</label>
                    <input type="number" id="bodyHeight" value="60">
                    <label for="bodyDensity">Плотность:</label>
                    <input type="number" id="bodyDensity" value="25">
                </div>
                
                <div class="attribute-group">
                    <h4>Дальнобойное оружие - Опционально</h4>
                    <label for="reloadTime">Время перезарядки:</label>
                    <input type="number" id="reloadTime" step="0.01" value="0.24">
                    <label for="weapondamagemodifier">Модификатор урона оружия:</label>
                    <input type="number" id="weapondamagemodifier" step="0.01" value="1.0">
                    <label for="crosshairscale">Масштаб прицела:</label>
                    <input type="number" id="crosshairscale" step="0.01" value="0.2">
                    <label for="penetration">Пробиваемость:</label>
                    <input type="text" id="penetration" value="">
                    <label for="holdtrigger">Удерживать курок:</label>
                    <select id="holdtrigger">
                        <option value="true">true</option>
                        <option value="false">false</option>
                    </select>
                    <label for="barrelPos">Позиция ствола (x,y):</label>
                    <input type="text" id="barrelPos" value="75,20" readonly>
                    <button type="button" class="coordinate-picker-btn" onclick="setPointSelectionMode('barrelPos')">Выбрать точку</button>
                    <label for="spread">Разброс:</label>
                    <input type="number" id="spread" value="6">
                    <label for="unskilledspread">Разброс при отсутствии навыка:</label>
                    <input type="number" id="unskilledspread" value="20">
                    <label for="combatPriority">Приоритет в бою:</label>
                    <input type="number" id="combatPriority" value="80">
                    <label for="drawhudwhenequipped">Отображать HUD при экипировке:</label>
                    <select id="drawhudwhenequipped">
                        <option value="true">true</option>
                        <option value="false">false</option>
                    </select>
                    <label for="crosshairTexture">Текстура прицела:</label>
                    <input type="text" id="crosshairTexture" value="Content/Items/Weapons/Crosshairs.png">
                    <label for="crosshairSourceRect">Исходный прямоугольник прицела:</label>
                    <input type="text" id="crosshairSourceRect" value="0,256,256,256">
                    <label for="crosshairPointerTexture">Текстура указателя прицела:</label>
                    <input type="text" id="crosshairPointerTexture" value="Content/Items/Weapons/Crosshairs.png">
                    <label for="crosshairPointerSourceRect">Исходный прямоугольник указателя прицела:</label>
                    <input type="text" id="crosshairPointerSourceRect" value="256,256,256,256">
                    <label for="rangedRequiredItems">Требуемые предметы (разделенные запятыми):</label>
                    <input type="text" id="rangedRequiredItems" value="smgammo">
                    <label for="rangedRequiredItemsType">Тип требуемых предметов:</label>
                    <input type="text" id="rangedRequiredItemsType" value="Contained">
                    <label for="rangedRequiredItemsMsg">Сообщение о требуемых предметах:</label>
                    <input type="text" id="rangedRequiredItemsMsg" value="ItemMsgAmmoRequired">
                    <label for="rangedRequiredSkillIdentifier">Идентификатор требуемого навыка:</label>
                    <input type="text" id="rangedRequiredSkillIdentifier" value="weapons">
                    <label for="rangedRequiredSkillLevel">Уровень требуемого навыка:</label>
                    <input type="number" id="rangedRequiredSkillLevel" value="60">
                    <p><small>Примечание: StatusEffect в RangedWeapon будет привязан к содержимому шаблона.</small></p>
                </div>

                <div class="attribute-group">
                    <h4>Контейнер для предметов</h4>
                    <label for="containerCapacity">Вместимость:</label>
                    <input type="number" id="containerCapacity" value="1">
                    <label for="containerMaxStackSize">Максимальный размер стака:</label>
                    <input type="number" id="containerMaxStackSize" value="1">
                    <label for="containerHideItems">Скрыть предметы:</label>
                    <select id="containerHideItems">
                        <option value="false">false</option>
                        <option value="true">true</option>
                    </select>
                    <label for="containedStateIndicatorSlot">Слот индикатора состояния содержимого:</label>
                    <input type="number" id="containedStateIndicatorSlot" value="0">
                    <label for="containedStateIndicatorStyle">Стиль индикатора состояния содержимого:</label>
                    <input type="text" id="containedStateIndicatorStyle" value="bullet">
                    <label for="containedSpriteDepth">Глубина спрайта содержимого:</label>
                    <input type="number" id="containedSpriteDepth" step="0.01" value="0.56">

                    <div id="subContainerGroups">
                        </div>
                    <button type="button" onclick="addSubContainer()">Добавить подконтейнер</button>

                </div>
                
                <div class="attribute-group">
                    <h5>Содержимое основного контейнера</h5>
                    <div id="mainContainables">
                        <div class="dynamic-item-group">
                            <button type="button" class="remove-btn" onclick="this.parentElement.remove(); renderCanvas();">Удалить</button>
                            <label>Предметы (разделенные запятыми): <input type="text" class="containable-items" value="smgammo,ammo"></label>
                            <label>Скрыть: <select class="containable-hide"><option value="false">false</option><option value="true">true</option></select></label>
                            <label>Позиция предмета (x,y): <input type="text" class="containable-itempos" id="mainContainableItemPos-0" value="-19,-1" readonly></label>
                            <button type="button" class="coordinate-picker-btn" onclick="setPointSelectionMode('mainContainableItemPos-0')">Выбрать точку</button>
                            <label>Вращение: <input type="number" class="containable-rotation" value="-30"></label>
                        </div>
                    </div>
                    <button type="button" onclick="addMainContainable()">Добавить элемент для основного контейнера</button>
                </div>
            </div>
        </div>

        <div class="right-column">
            <div class="section-panel">
                <h2>Редактирование изображений и координат</h2>
                <label for="imageUpload">Загрузить текстуру предмета:</label>
                <input type="file" id="imageUpload" accept="image/*">
                <div class="mode-buttons">
                    <button id="modeSourcerect" onclick="setMode('sourcerect')">Выбрать область текстуры</button>
                </div>
                <canvas id="imageCanvas" class="grabbing" ></canvas>
                <h3>Спрайт</h3>
                <label for="spriteTexture">Путь к текстуре:</label>
                <input type="text" id="spriteTexture" value="Content/Items/Weapons/weapons_new.png" placeholder="Измените в соответствии с путем к файлу вашей игры">
                <label for="spriteSourceRect">Исходный прямоугольник спрайта предмета (x,y,ширина,высота):</label>
                <input type="text" id="spriteSourceRect" value="94,8,161,59" readonly>
                <label for="spriteDepth">Глубина:</label>
                <input type="number" id="spriteDepth" step="0.01" value="0.55">
                <label for="spriteOrigin">Начало координат (x,y):</label>
                <input type="text" id="spriteOrigin" value="0.5,0.5">
                <p style="font-size: 0.9em; color: #777;">Обычно 0.5,0.5 (центр). Координаты точки удержания будут рассчитываться относительно этого начала координат.</p>
                <h3>Иконка инвентаря</h3>
                <label for="inventoryIconTexture">Путь к текстуре:</label>
                <input type="text" id="inventoryIconTexture" value="Content/Items/InventoryIconAtlas.png">
                <label for="inventoryIconSourceRect">Исходный прямоугольник иконки инвентаря (x,y,ширина,высота):</label>
                <input type="text" id="inventoryIconSourceRect" value="94,8,161,59" readonly>
                <label for="inventoryIconOrigin">Начало координат (x,y):</label>
                <input type="text" id="inventoryIconOrigin" value="0.5,0.5">
                <p style="font-size: 0.9em; color: #777;">По умолчанию соответствует исходному прямоугольнику спрайта предмета. Путь к текстуре иконки инвентаря обычно `Content/Items/InventoryIconAtlas.png`.</p>
            </div>
            
            <div class="section-panel">
                <div class="attribute-group">
                    <h4>Удерживаемый</h4>
                    <label for="holdableSlots">Слоты (разделенные запятыми):</label>
                    <input type="text" id="holdableSlots" value="Any,RightHand+LeftHand">
                    <label for="controlPose">Поза управления:</label>
                    <select id="controlPose">
                        <option value="true">true</option>
                        <option value="false">false</option>
                    </select>
                    <label for="holdPos">Позиция удержания (x,y):</label>
                    <input type="text" id="holdPos" value="40,-10">
                    <label for="aimPos">Позиция прицеливания (x,y):</label>
                    <input type="text" id="aimPos" value="45,-10">
                    <label for="handle1Pos">Рукоятка 1 (dx,dy):</label>
                    <input type="text" id="handle1Pos" value="-30,15" readonly>
                    <button type="button" class="coordinate-picker-btn" onclick="setPointSelectionMode('handle1Pos')">Выбрать точку</button>
                    <label for="handle2Pos">Рукоятка 2 (dx,dy):</label>
                    <input type="text" id="handle2Pos" value="26,-5" readonly>
                    <button type="button" class="coordinate-picker-btn" onclick="setPointSelectionMode('handle2Pos')">Выбрать точку</button>
                    <label for="holdAngle">Угол удержания:</label>
                    <input type="number" id="holdAngle" value="-35">
                    <label for="holdableMsg">Сообщение:</label>
                    <input type="text" id="holdableMsg" value="ItemMsgPickUpSelect">
                </div>
                <div class="attribute-group">
                    <h4>Цель ИИ</h4>
                    <label for="aiTargetSightRange">Дальность обзора:</label>
                    <input type="number" id="aiTargetSightRange" value="2000" step="1">
                    <label for="aiTargetSoundRange">Дальность звука:</label>
                    <input type="number" id="aiTargetSoundRange" value="5000" step="1">
                    <label for="aiTargetFadeOutTime">Время затухания:</label>
                    <input type="number" id="aiTargetFadeOutTime" value="5" step="0.1">
                </div>
                <div class="attribute-group">
                    <h4>Качество</h4>
                    <label for="qualityStatType">Тип статистики:</label>
                    <input type="text" id="qualityStatType" value="FirepowerMultiplier">
                    <label for="qualityValue">Значение:</label>
                    <input type="number" id="qualityValue" value="0.1" step="0.01">
                </div>
                <div class="attribute-group">
                    <h4>Подсказка о требовании навыка</h4>
                    <label for="skillHintIdentifier">Идентификатор:</label>
                    <input type="text" id="skillHintIdentifier" value="weapons">
                    <label for="skillHintLevel">Уровень:</label>
                    <input type="number" id="skillHintLevel" value="40" step="1">
                </div>
            </div>

            <div class="section-panel output-section">
                <h2>Сгенерированный XML</h2>
                <pre id="xmlOutput"></pre>
                <button onclick="generateXml()" style="margin-top: 20px;">Сгенерировать XML</button>
                <p style="color: red; font-weight: bold; margin-top: 15px;">Предупреждение: Точки удержания и позиции контейнеров обычно неточны и требуют тонкой настройки в игре.</p>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const CANVAS_FIXED_WIDTH = 800; // Фиксированная ширина холста
        const CANVAS_FIXED_HEIGHT = 600; // Фиксированная высота холста

        // --- Global State Variables ---
        let uploadedImage = new Image();
        let currentMode = 'none'; // 'none', 'sourcerect', 'pointSelection'
        let activeCoordinateInput = null; // Хранит элемент ввода для заполнения в режиме выбора точки

        // Zoom and Pan state
        let scale = 1.0; // Текущий уровень масштабирования
        let panX = 0; // Смещение по X
        let panY = 0; // Смещение по Y
        let isPanning = false;
        let lastPanX = 0;
        let lastPanY = 0;

        // Sourcerect selection state
        let isDrawing = false;
        let startX_canvas_screen = 0; // Нажатие мыши по X на холсте (координаты клиента относительно элемента холста)
        let startY_canvas_screen = 0; // Нажатие мыши по Y на холсте (координаты клиента относительно элемента холста)
        let currentDrawingRect_canvas_transformed = null; // Временный прямоугольник при рисовании (в координатах изображения, преобразованных холстом)

        // Stored values for persistent drawing (in original image pixels) - These are Barotrauma-style coordinates (Y-up is positive)
        let selectedSourcerect = { x: 94, y: 8, width: 161, height: 59 }; // Начальные значения из примера пользователя
        let selectedHandle1 = { x: -30, y: 15 }; // В стиле Barotrauma (Y-вверх положительный)
        let selectedHandle2 = { x: 26, y: -5 }; // В стиле Barotrauma (Y-вверх положительный)
        let selectedBarrelPos = { x: 75, y: 20 }; // В стиле Barotrauma (Y-вверх положительный)
        let selectedItemPos = { // Начальные значения из примера пользователя - В стиле Barotrauma (Y-вверх положительный)
            "mainContainableItemPos-0": {x: -19, y: -1}
            // Removed specific sub-container item positions here, they will be dynamically added.
        };

        // --- Canvas Setup ---
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas display size and internal drawing size
        canvas.width = CANVAS_FIXED_WIDTH;
        canvas.height = CANVAS_FIXED_HEIGHT;

        // --- Event Listeners ---
        document.getElementById('imageUpload').addEventListener('change', handleImageUpload);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseout', handleMouseUp); // Завершить рисование/панорамирование, если мышь покидает холст
        canvas.addEventListener('wheel', handleWheel);

        // Initial setup for existing coordinate inputs
        document.addEventListener('DOMContentLoaded', () => {
            renderCanvas();
        });


        // --- Image Loading and Rendering ---
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    uploadedImage.onload = () => {
                        // Сбросить масштаб и панорамирование при загрузке нового изображения
                        scale = 1.0;
                        panX = 0;
                        panY = 0;
                        // Сохранить текущий выбранныйSourcerect, но очистить временный прямоугольник рисования
                        currentDrawingRect_canvas_transformed = null;

                        renderCanvas();
                    };
                    uploadedImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        function renderCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Очистить холст

            if (uploadedImage.src) {
                // Сохранить текущую матрицу преобразования
                ctx.save();

                // Применить панорамирование и масштабирование
                ctx.translate(panX, panY);
                ctx.scale(scale, scale);

                // Нарисовать изображение
                ctx.drawImage(uploadedImage, 0, 0, uploadedImage.width, uploadedImage.height);

                // Нарисовать выбранный sourcerect (в исходных пикселях изображения, уже учтено панорамированием/масштабированием)
                if (selectedSourcerect.width > 0 && selectedSourcerect.height > 0) {
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2 / scale; // Отрегулировать ширину линии для масштабирования
                    ctx.strokeRect(selectedSourcerect.x, selectedSourcerect.y, selectedSourcerect.width, selectedSourcerect.height);
                }

                // Нарисовать текущий прямоугольник рисования (в пикселях изображения, преобразованный панорамированием/масштабированием)
                if (currentDrawingRect_canvas_transformed) {
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 2 / scale; // Отрегулировать ширину линии для масштабирования
                    ctx.strokeRect(
                        currentDrawingRect_canvas_transformed.x,
                        currentDrawingRect_canvas_transformed.y,
                        currentDrawingRect_canvas_transformed.width,
                        currentDrawingRect_canvas_transformed.height
                    );
                }

                // Получить itemScale для рисования точек
                const itemScaleVal = parseFloat(document.getElementById('itemScale').value) || 1.0;

                // Нарисовать точки рукояток (x, y в стиле Barotrauma, поэтому Y нужно инвертировать для рисования на холсте)
                // Сохраненные точки уже масштабированы.
                drawPoint(selectedHandle1.x, selectedHandle1.y, 'handle1Pos', 'red', 'red', itemScaleVal);
                drawPoint(selectedHandle2.x, selectedHandle2.y, 'handle2Pos', 'green', 'green', itemScaleVal);
                drawPoint(selectedBarrelPos.x, selectedBarrelPos.y, 'barrelPos', 'purple', 'purple', itemScaleVal);

                // Нарисовать динамические точки itempos
                for (const id in selectedItemPos) {
                    const pos = selectedItemPos[id];
                    drawPoint(pos.x, pos.y, id, 'orange', 'orange', itemScaleVal);
                }

                // Восстановить матрицу преобразования
                ctx.restore();
            }
        }

        function drawPoint(x, y, inputId, strokeColor, fillColor, itemScaleVal) {
            if (!uploadedImage.src) return;

            const spriteOriginInput = document.getElementById('spriteOrigin').value || "0.5,0.5";
            const [originXRatio, originYRatio] = spriteOriginInput.split(',').map(Number);
            
            const spriteSourceRectInput = document.getElementById('spriteSourceRect').value;
            let spriteWidth = uploadedImage.width;
            let spriteHeight = uploadedImage.height;
            let spriteRectX = 0;
            let spriteRectY = 0;

            if (spriteSourceRectInput) {
                const parts = spriteSourceRectInput.split(',').map(Number);
                if (parts.length === 4) {
                    spriteRectX = parts[0];
                    spriteRectY = parts[1];
                    spriteWidth = parts[2];
                    spriteHeight = parts[3];
                }
            }
            
            // Unscale the point for drawing on the base image, as the visual representation should be scaled
            // The stored x,y values are already scaled, so we divide by itemScaleVal to get the unscaled position
            // relative to the item's unscaled dimensions. This unscaled position is then offset by the origin
            // and spriteRect to get the global image coordinate for drawing.
            const unscaledX = x / itemScaleVal;
            const unscaledY = y / itemScaleVal;

            // Calculate origin pixel coordinates relative to the *top-left of the original image/sourcerect*
            // globalX and globalY are coordinates on the image itself.
            const globalX = spriteRectX + (originXRatio * spriteWidth) + unscaledX;
            // Y is Barotrauma-style (up is positive), so to draw on canvas (down is positive), invert Y
            const globalY_for_drawing = spriteRectY + (originYRatio * spriteHeight) - unscaledY;


            // Draw the circle - ctx is already transformed by pan and zoom
            ctx.beginPath();
            const radius = 5 / scale; // Отрегулировать радиус для масштабирования
            ctx.arc(globalX, globalY_for_drawing, radius, 0, Math.PI * 2);
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2 / scale;
            ctx.stroke();
            ctx.fillStyle = fillColor;
            ctx.fill();

            // Draw label
            ctx.font = `${12 / scale}px Arial`;
            ctx.fillStyle = 'black';
            // Offset label slightly
            let labelText = inputId.replace('Pos', '');
            if (inputId.startsWith('mainContainableItemPos-')) {
                labelText = `ОсновнаяПозицияПредмета ${inputId.split('-')[1]}`;
            } else if (inputId.startsWith('subContainableItemPos-')) {
                // The label will be "CustomItemPos {timestamp}" for generic subcontainers
                labelText = `ПозицияПодПредмета ${inputId.split('-')[1]}`;
            }
            ctx.fillText(labelText, globalX + radius + (2 / scale), globalY_for_drawing + radius + (2 / scale));
        }


        // --- Mouse Event Handlers ---
        function getTransformedMouseCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX_screen = e.clientX - rect.left;
            const mouseY_screen = e.clientY - rect.top;

            // Convert screen coordinates to canvas-transformed image coordinates (x right, y down)
            const mouseX_transformed = (mouseX_screen - panX) / scale;
            const mouseY_transformed = (mouseY_screen - panY) / scale;
            return { x: mouseX_transformed, y: mouseY_transformed };
        }

        function handleMouseDown(e) {
            if (!uploadedImage.src) return;

            const { x: mouseX_transformed, y: mouseY_transformed } = getTransformedMouseCoordinates(e);

            if (currentMode === 'sourcerect') {
                isDrawing = true;
                startX_canvas_screen = e.clientX - canvas.getBoundingClientRect().left; // Store screen coords for calculating movement
                startY_canvas_screen = e.clientY - canvas.getBoundingClientRect().top;

                // Initialize currentDrawingRect in transformed image coordinates
                currentDrawingRect_canvas_transformed = {
                    x: mouseX_transformed,
                    y: mouseY_transformed,
                    width: 0,
                    height: 0
                };
                canvas.classList.add('grabbing');
            } else if (currentMode === 'pointSelection') {
                if (activeCoordinateInput) {
                    const spriteOriginInput = document.getElementById('spriteOrigin').value || "0.5,0.5";
                    const [originXRatio, originYRatio] = spriteOriginInput.split(',').map(Number);

                    const spriteSourceRectInput = document.getElementById('spriteSourceRect').value;
                    let spriteWidth = uploadedImage.width;
                    let spriteHeight = uploadedImage.height;
                    let spriteRectX = 0;
                    let spriteRectY = 0;
                    if (spriteSourceRectInput) {
                        const parts = spriteSourceRectInput.split(',').map(Number);
                        if (parts.length === 4) {
                            spriteRectX = parts[0];
                            spriteRectY = parts[1];
                            spriteWidth = parts[2];
                            spriteHeight = parts[3];
                        }
                    }

                    // Calculate point relative to sprite origin (Canvas style: X right, Y down from origin)
                    const tempPointX_canvasStyle = mouseX_transformed - (spriteRectX + originXRatio * spriteWidth);
                    const tempPointY_canvasStyle = mouseY_transformed - (spriteRectY + originYRatio * spriteHeight);

                    // Convert to Barotrauma style (X right, Y up from origin)
                    let pointX_barotraumaStyle = tempPointX_canvasStyle;
                    let pointY_barotraumaStyle = -tempPointY_canvasStyle;

                    // Get itemScale and apply it
                    const itemScaleVal = parseFloat(document.getElementById('itemScale').value) || 1.0;
                    pointX_barotraumaStyle = Math.round(pointX_barotraumaStyle * itemScaleVal);
                    pointY_barotraumaStyle = Math.round(pointY_barotraumaStyle * itemScaleVal);


                    activeCoordinateInput.value = `${pointX_barotraumaStyle},${pointY_barotraumaStyle}`;
                    updateCoordinate(activeCoordinateInput.id, pointX_barotraumaStyle, pointY_barotraumaStyle);
                    setMode('none'); // Exit point selection mode
                }
            } else { // Panning mode
                isPanning = true;
                lastPanX = e.clientX - canvas.getBoundingClientRect().left;
                lastPanY = e.clientY - canvas.getBoundingClientRect().top;
                canvas.classList.add('grabbing');
            }
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX_canvas = e.clientX - rect.left;
            const mouseY_canvas = e.clientY - rect.top;

            if (isDrawing) {
                // Calculate dimensions in transformed image coordinates
                const currentX_transformed = (mouseX_canvas - panX) / scale;
                const currentY_transformed = (mouseY_canvas - panY) / scale;
                
                currentDrawingRect_canvas_transformed.width = currentX_transformed - currentDrawingRect_canvas_transformed.x;
                currentDrawingRect_canvas_transformed.height = currentY_transformed - currentDrawingRect_canvas_transformed.y;
                renderCanvas();
            } else if (isPanning) {
                const dx = mouseX_canvas - lastPanX;
                const dy = mouseY_canvas - lastPanY;
                panX += dx;
                panY += dy;
                lastPanX = mouseX_canvas;
                lastPanY = mouseY_canvas;
                renderCanvas();
            }
        }

        function handleMouseUp() {
            if (isDrawing) {
                isDrawing = false;
                canvas.classList.remove('grabbing');

                // Ensure width/height are positive
                let finalRect = {
                    x: currentDrawingRect_canvas_transformed.x,
                    y: currentDrawingRect_canvas_transformed.y,
                    width: currentDrawingRect_canvas_transformed.width,
                    height: currentDrawingRect_canvas_transformed.height
                };

                if (finalRect.width < 0) {
                    finalRect.x += finalRect.width;
                    finalRect.width *= -1;
                }
                if (finalRect.height < 0) {
                    finalRect.y += finalRect.height;
                    finalRect.height *= -1;
                }

                selectedSourcerect = {
                    x: Math.round(finalRect.x),
                    y: Math.round(finalRect.y),
                    width: Math.round(finalRect.width),
                    height: Math.round(finalRect.height)
                };

                document.getElementById('spriteSourceRect').value = `${selectedSourcerect.x},${selectedSourcerect.y},${selectedSourcerect.width},${selectedSourcerect.height}`;
                document.getElementById('inventoryIconSourceRect').value = `${selectedSourcerect.x},${selectedSourcerect.y},${selectedSourcerect.width},${selectedSourcerect.height}`;

                currentDrawingRect_canvas_transformed = null; // Clear temporary rect
                renderCanvas();
            } else if (isPanning) {
                isPanning = false;
                canvas.classList.remove('grabbing');
            }
        }

        function handleWheel(e) {
            e.preventDefault(); // Запретить прокрутку страницы

            const zoomIntensity = 0.1;
            const mouseX = e.clientX - canvas.getBoundingClientRect().left;
            const mouseY = e.clientY - canvas.getBoundingClientRect().top;

            const scaleFactor = e.deltaY < 0 ? (1 + zoomIntensity) : (1 - zoomIntensity);

            // Calculate new pan to zoom around mouse cursor
            panX = mouseX - ((mouseX - panX) * scaleFactor);
            panY = mouseY - ((mouseY - panY) * scaleFactor);
            scale *= scaleFactor;

            // Limit zoom
            if (scale < 0.1) scale = 0.1;
            if (scale > 10) scale = 10;

            renderCanvas();
        }

        // --- Mode Control ---
        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-buttons button').forEach(btn => btn.classList.remove('active'));
            if (mode !== 'none') {
                document.getElementById('mode' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');
            }
            if (mode === 'pointSelection' || mode === 'sourcerect') {
                canvas.style.cursor = 'crosshair';
            } else {
                canvas.style.cursor = 'grab';
            }
            activeCoordinateInput = null; // Clear active input when changing mode
        }

        function setPointSelectionMode(inputId) {
            activeCoordinateInput = document.getElementById(inputId);
            setMode('pointSelection');
        }

        function updateCoordinate(id, x, y) {
            if (id === 'handle1Pos') selectedHandle1 = { x, y };
            else if (id === 'handle2Pos') selectedHandle2 = { x, y };
            else if (id === 'barrelPos') selectedBarrelPos = { x, y };
            else if (id.startsWith('mainContainableItemPos-')) selectedItemPos[id] = {x, y};
            else if (id.startsWith('subContainableItemPos-')) selectedItemPos[id] = {x, y};
            renderCanvas();
        }
        
        // --- Dynamic Content Functions ---
        function addPrice() {
            const container = document.getElementById('dynamicPrices');
            const index = container.children.length;
            const div = document.createElement('div');
            div.className = 'dynamic-item-group';
            div.innerHTML = `
                <button type="button" class="remove-btn" onclick="this.parentElement.remove()">Удалить</button>
                <label>Идентификатор магазина: <input type="text" class="price-storeidentifier" value=""></label>
                <label>Продается: <select class="price-sold"><option value="false">false</option><option value="true">true</option></select></label>
                <label>Множитель: <input type="number" class="price-multiplier" step="0.01" value="1.0"></label>
                <label>Мин. доступность: <input type="number" class="price-minavailable" value=""></label>
            `;
            container.appendChild(div);
        }

        function addPreferredContainer() {
            const container = document.getElementById('dynamicPreferredContainers');
            const index = container.children.length;
            const div = document.createElement('div');
            div.className = 'dynamic-item-group';
            div.innerHTML = `
                <button type="button" class="remove-btn" onclick="this.parentElement.remove()">Удалить</button>
                <label>Идентификатор: <input type="text" class="preferred-container-identifier" value="engsuitlocker"></label>
                <label>Тип: <input type="text" class="preferred-container-type" value="Cargo"></label>
            `;
            container.appendChild(div);
        }

        function addFabricateRequiredItem() {
            const container = document.getElementById('dynamicFabricateRequiredItems');
            const index = container.children.length;
            const div = document.createElement('div');
            div.className = 'dynamic-item-group';
            div.innerHTML = `
                <button type="button" class="remove-btn" onclick="this.parentElement.remove()">Удалить</button>
                <label>Идентификатор предмета: <input type="text" class="fabricate-item-identifier" value="steel"></label>
                <label>Количество: <input type="number" class="fabricate-item-amount" value="1"></label>
                <label>Мин. состояние (-1 для игнорирования): <input type="number" class="fabricate-mincondition" step="0.01" value="0"></label>
            `;
            container.appendChild(div);
        }

        function addDeconstructItem() {
            const container = document.getElementById('dynamicDeconstructItems');
            const index = container.children.length;
            const div = document.createElement('div');
            div.className = 'dynamic-item-group';
            div.innerHTML = `
                <button type="button" class="remove-btn" onclick="this.parentElement.remove()">Удалить</button>
                <label>Идентификатор предмета: <input type="text" class="deconstruct-item-identifier" value="plastic"></label>
            `;
            container.appendChild(div);
        }

        function addMainContainable() {
            const container = document.getElementById('mainContainables');
            const index = container.children.length;
            const div = document.createElement('div');
            div.className = 'dynamic-item-group';
            const itemPosId = `mainContainableItemPos-${Date.now()}`; // Use timestamp for unique ID
            div.innerHTML = `
                <button type="button" class="remove-btn" onclick="this.parentElement.remove(); renderCanvas();">Удалить</button>
                <label>Предметы (разделенные запятыми): <input type="text" class="containable-items" value="any, ammo"></label>
                <label>Скрыть: <select class="containable-hide"><option value="false">false</option><option value="true">true</option></select></label>
                <label>Позиция предмета (x,y): <input type="text" class="containable-itempos" id="${itemPosId}" value="0,0" readonly></label>
                <button type="button" class="coordinate-picker-btn" onclick="setPointSelectionMode('${itemPosId}')">Выбрать точку</button>
                <label>Вращение: <input type="number" class="containable-rotation" value="0"></label>
            `;
            container.appendChild(div);
            selectedItemPos[itemPosId] = {x:0, y:0}; // Initialize new point for rendering (Barotrauma style)
            renderCanvas();
        }

        function addSubContainer() { // Removed type parameter as only one generic type is desired
            const containerGroups = document.getElementById('subContainerGroups');
            const newGroup = document.createElement('div');
            newGroup.className = 'sub-container-group dynamic-item-group';
            // Removed data-default-type attribute as it's no longer relevant

            const title = 'Пользовательский подконтейнер'; // Always "Custom Subcontainer"
            const defaultItems = 'any'; // Always "any"

            const itemPosId = `subContainableItemPos-${Date.now()}`; // Unique ID for itempos

            newGroup.innerHTML = `
                <button type="button" class="remove-btn" onclick="this.parentElement.remove(); renderCanvas();">×</button>
                <h4>${title}</h4>
                <label>Содержимые предметы (разделенные запятыми): <input type="text" class="sub-containable-items" value="${defaultItems}"></label>
                <label>Скрыть: <select class="sub-containable-hide"><option value="false">false</option><option value="true">true</option></select></label>
                <label>Позиция предмета (x,y): <input type="text" class="sub-containable-itempos" id="${itemPosId}" value="0,0" readonly></label>
                <button type="button" class="coordinate-picker-btn" onclick="setPointSelectionMode('${itemPosId}')">Выбрать точку</button>
                <label>Сделать активным: <select class="sub-containable-setactive"><option value="true">true</option><option value="false">false</option></select></label>
            `;
            containerGroups.appendChild(newGroup);
            selectedItemPos[itemPosId] = {x:0, y:0}; // Initialize new point for rendering (Barotrauma style)
            renderCanvas();
        }

        // --- XML Generation ---
        function generateXml() {
            const itemIdentifier = document.getElementById('itemIdentifier').value || 'newitem';
            const itemName = document.getElementById('itemName').value;
            const tags = document.getElementById('tags').value;
            const itemCategory = document.getElementById('itemCategory').value;
            const subcategory = document.getElementById('subcategory').value;
            const impactSoundTag = document.getElementById('impactSoundTag').value;
            const itemScale = document.getElementById('itemScale').value; // New item-level scale

            const interactDistance = document.getElementById('interactDistance').value;
            const interactPriority = document.getElementById('interactPriority').value;
            const interactThroughWalls = document.getElementById('interactThroughWalls').value;
            const focusOnSelected = document.getElementById('focusOnSelected').value;
            const offsetOnSelected = document.getElementById('offsetOnSelected').value;
            const showContentsInTooltip = document.getElementById('showContentsInTooltip').value;
            const spriteColor = document.getElementById('spriteColor').value;

            const health = document.getElementById('health').value;
            const indestructible = document.getElementById('indestructible').value;
            const fireProof = document.getElementById('fireProof').value;
            const waterProof = document.getElementById('waterProof').value;
            const impactTolerance = document.getElementById('impactTolerance').value;

            const maxStackSize = document.getElementById('maxStackSize').value;
            const allowAsExtraCargo = document.getElementById('allowAsExtraCargo').value;
            const cargoContainerIdentifier = document.getElementById('cargoContainerIdentifier').value;
            const allowRotatingInEditor = document.getElementById('allowRotatingInEditor').value;
            const linkable = document.getElementById('linkable').value;

            const basePrice = document.getElementById('basePrice').value;

            const fabricateTime = document.getElementById('fabricateTime').value;
            const fabricateSuitableFabricators = document.getElementById('fabricateSuitableFabricators').value;
            
            const deconstructTime = document.getElementById('deconstructTime').value;

            const bodyWidth = document.getElementById('bodyWidth').value;
            const bodyHeight = document.getElementById('bodyHeight').value;
            const bodyDensity = document.getElementById('bodyDensity').value;

            const reloadTime = document.getElementById('reloadTime').value;
            const weaponDamageModifier = document.getElementById('weapondamagemodifier').value;
            const crosshairscale = document.getElementById('crosshairscale').value; // Get crosshairscale value
            const penetration = document.getElementById('penetration').value; // Can be empty string
            const holdtrigger = document.getElementById('holdtrigger').value;
            const barrelPos = document.getElementById('barrelPos').value;
            const spread = document.getElementById('spread').value;
            const unskilledspread = document.getElementById('unskilledspread').value;
            const combatPriority = document.getElementById('combatPriority').value;
            const drawhudwhenequipped = document.getElementById('drawhudwhenequipped').value;
            const crosshairTexture = document.getElementById('crosshairTexture').value;
            const crosshairSourceRect = document.getElementById('crosshairSourceRect').value;
            const crosshairPointerTexture = document.getElementById('crosshairPointerTexture').value;
            const crosshairPointerSourceRect = document.getElementById('crosshairPointerSourceRect').value;
            const rangedRequiredItems = document.getElementById('rangedRequiredItems').value;
            const rangedRequiredItemsType = document.getElementById('rangedRequiredItemsType').value;
            const rangedRequiredItemsMsg = document.getElementById('rangedRequiredItemsMsg').value;
            const rangedRequiredSkillIdentifier = document.getElementById('rangedRequiredSkillIdentifier').value;
            const rangedRequiredSkillLevel = document.getElementById('rangedRequiredSkillLevel').value;

            const containerCapacity = document.getElementById('containerCapacity').value;
            const containerMaxStackSize = document.getElementById('containerMaxStackSize').value;
            const containerHideItems = document.getElementById('containerHideItems').value;
            const containedStateIndicatorSlot = document.getElementById('containedStateIndicatorSlot').value;
            const containedStateIndicatorStyle = document.getElementById('containedStateIndicatorStyle').value;
            const containedSpriteDepth = document.getElementById('containedSpriteDepth').value;

            const spriteTexture = document.getElementById('spriteTexture').value;
            const spriteSourceRect = document.getElementById('spriteSourceRect').value;
            const spriteDepth = document.getElementById('spriteDepth').value;
            const spriteOrigin = document.getElementById('spriteOrigin').value;
            // const spriteScale = document.getElementById('spriteScale').value; // Removed

            const inventoryIconTexture = document.getElementById('inventoryIconTexture').value;
            const inventoryIconSourceRect = document.getElementById('inventoryIconSourceRect').value;
            const inventoryIconOrigin = document.getElementById('inventoryIconOrigin').value;

            const holdableSlots = document.getElementById('holdableSlots').value;
            const controlPose = document.getElementById('controlPose').value;
            const holdPos = document.getElementById('holdPos').value;
            const aimPos = document.getElementById('aimPos').value;
            const handle1Pos = document.getElementById('handle1Pos').value;
            const handle2Pos = document.getElementById('handle2Pos').value;
            const holdAngle = document.getElementById('holdAngle').value;
            const holdableMsg = document.getElementById('holdableMsg').value;

            // New AI Target fields
            const aiTargetSightRange = document.getElementById('aiTargetSightRange').value;
            const aiTargetSoundRange = document.getElementById('aiTargetSoundRange').value;
            const aiTargetFadeOutTime = document.getElementById('aiTargetFadeOutTime').value;

            // New Quality fields
            const qualityStatType = document.getElementById('qualityStatType').value;
            const qualityValue = document.getElementById('qualityValue').value;

            // New Skill Requirement Hint fields
            const skillHintIdentifier = document.getElementById('skillHintIdentifier').value;
            const skillHintLevel = document.getElementById('skillHintLevel').value;
            
            let xml = `<Item identifier="${itemIdentifier}"`;

            if (itemName) xml += ` name="${itemName}"`;
            if (tags) xml += ` tags="${tags}"`;
            if (itemCategory) xml += ` category="${itemCategory}"`;
            if (subcategory) xml += ` subcategory="${subcategory}"`;
            xml += ` scale="${itemScale}"`; // Use new item-level scale
            if (impactSoundTag) xml += ` impactsoundtag="${impactSoundTag}"`;

            xml += ` interactdistance="${interactDistance}"`;
            xml += ` interactpriority="${interactPriority}"`;
            xml += ` interactthroughwalls="${interactThroughWalls}"`;
            xml += ` focusonselected="${focusOnSelected}"`;
            xml += ` offsetonselected="${offsetOnSelected}"`;
            xml += ` showcontentsintooltip="${showContentsInTooltip}"`;
            xml += ` health="${health}"`;
            xml += ` indestructible="${indestructible}"`;
            xml += ` fireproof="${fireProof}"`;
            xml += ` waterproof="${waterProof}"`;
            xml += ` impacttolerance="${impactTolerance}"`;
            xml += ` maxstacksize="${maxStackSize}"`;
            xml += ` allowasextracargo="${allowAsExtraCargo}"`;
            if (cargoContainerIdentifier) xml += ` cargocontaineridentifier="${cargoContainerIdentifier}"`;
            xml += ` allowrotatingineditor="${allowRotatingInEditor}"`;
            xml += ` linkable="${linkable}"`;

            xml += `>\n`;

            // Price
            xml += `  <Price baseprice="${basePrice}">\n`;
            document.querySelectorAll('#dynamicPrices .dynamic-item-group').forEach(group => {
                const storeidentifier = group.querySelector('.price-storeidentifier').value;
                const sold = group.querySelector('.price-sold').value;
                const multiplier = group.querySelector('.price-multiplier').value;
                const minavailable = group.querySelector('.price-minavailable').value;

                let priceLine = `    <Price storeidentifier="${storeidentifier}"`;
                if (sold !== 'false') priceLine += ` sold="${sold}"`; 
                priceLine += ` multiplier="${multiplier}"`;
                if (minavailable) priceLine += ` minavailable="${minavailable}"`;
                priceLine += ` />\n`;
                xml += priceLine;
            });
            xml += `  </Price>\n`;

            // PreferredContainer (Dynamic)
            document.querySelectorAll('#dynamicPreferredContainers .dynamic-item-group').forEach(group => {
                const identifier = group.querySelector('.preferred-container-identifier').value;
                const type = group.querySelector('.preferred-container-type').value;
                xml += `  <PreferredContainer identifier="${identifier}" type="${type}" />\n`;
            });

            // Fabricate
            xml += `  <Fabricate requiredtime="${fabricateTime}" suitablefabricators="${fabricateSuitableFabricators}">\n`;
            document.querySelectorAll('#dynamicFabricateRequiredItems .dynamic-item-group').forEach(group => {
                const identifier = group.querySelector('.fabricate-item-identifier').value;
                const amount = group.querySelector('.fabricate-item-amount').value;
                const mincondition = group.querySelector('.fabricate-mincondition').value;
                xml += `    <RequiredItem identifier="${identifier}" amount="${amount}" mincondition="${mincondition}" />\n`;
            });
            xml += `  </Fabricate>\n`;

            // Deconstruct
            xml += `  <Deconstruct time="${deconstructTime}">\n`;
            document.querySelectorAll('#dynamicDeconstructItems .dynamic-item-group').forEach(group => {
                const identifier = group.querySelector('.deconstruct-item-identifier').value;
                xml += `    <Item identifier="${identifier}" />\n`;
            });
            xml += `  </Deconstruct>\n`;

            // Body
            xml += `  <Body width="${bodyWidth}" height="${bodyHeight}" density="${bodyDensity}" />\n`;
            
            // InventoryIcon - Moved after Body
            xml += `  <InventoryIcon texture="${inventoryIconTexture}" sourcerect="${inventoryIconSourceRect}" origin="${inventoryIconOrigin}" />\n`;

            // NEW: PreferredContainer (Static) - Added here before Sprite
            xml += `  <PreferredContainer primary="secarmcab" secondary="armcab,weaponholder" />\n`;

            // Sprite - Moved after Body and InventoryIcon
            xml += `  <Sprite texture="${spriteTexture}" sourcerect="${spriteSourceRect}" depth="${spriteDepth}" origin="${spriteOrigin}" scale="1.0" `; // Fixed scale to 1.0
            // Add SpriteColor if it's set
            if (spriteColor) {
                xml += `color="${spriteColor}"`;
            }
            xml += `/>\n`;

            // Holdable - Moved before RangedWeapon
            xml += `  <Holdable slots="${holdableSlots}" controlpose="${controlPose}" holdpos="${holdPos}" aimpos="${aimPos}" handle1="${handle1Pos}" handle2="${handle2Pos}" holdangle="${holdAngle}" msg="${holdableMsg}" />\n`;


            // RangedWeapon (if reloadTime is provided, assume it's a ranged weapon)
            if (reloadTime) {
                xml += `  <RangedWeapon reload="${reloadTime}" weapondamagemodifier="${weaponDamageModifier}" crosshairscale="${crosshairscale}" penetration="${penetration}" holdtrigger="${holdtrigger}" barrelpos="${barrelPos}" spread="${spread}" unskilledspread="${unskilledspread}" combatpriority="${combatPriority}" drawhudwhenequipped="${drawhudwhenequipped}">\n`;
                xml += `    <Crosshair texture="${crosshairTexture}" sourcerect="${crosshairSourceRect}" />\n`; // CORRECTED LINE: Removed scale attribute
                xml += `    <CrosshairPointer texture="${crosshairPointerTexture}" sourcerect="${crosshairPointerSourceRect}" />\n`;
                // Added ParticleEmitter as requested
                xml += `    <ParticleEmitter particle="muzzleflash" particleamount="1" velocitymin="0" velocitymax="0" />\n`;
                if (rangedRequiredItems) {
                    xml += `    <RequiredItems items="${rangedRequiredItems}" type="${rangedRequiredItemsType}" msg="${rangedRequiredItemsMsg}" />\n`;
                }
                if (rangedRequiredSkillIdentifier) {
                    xml += `    <RequiredSkill identifier="${rangedRequiredSkillIdentifier}" level="${rangedRequiredSkillLevel}" />\n`;
                }
                // Updated StatusEffects as per user's request, removed OnSecondaryUse
                xml += `    <StatusEffect type="OnUse" target="This">\n`;
                xml += `      <ParticleEmitter particle="casingfirearm" particleamount="1" anglemin="90" anglemax="150" velocitymin="50" velocitymax="250" CopyEntityAngle="true" />\n`;
                xml += `      <Explosion range="150.0" force="1.5" shockwave="false" smoke="false" flames="false" sparks="false" underwaterbubble="false" camerashake="12.0" />\n`;
                xml += `    </StatusEffect>\n`;
                xml += `    <StatusEffect type="OnUse" target="Contained">\n`;
                xml += `      <Use />\n`;
                xml += `    </StatusEffect>\n`;
                xml += `  </RangedWeapon>\n`;
            }

            // ItemContainer
            xml += `  <ItemContainer capacity="${containerCapacity}" maxstacksize="${containerMaxStackSize}" hideitems="${containerHideItems}" containedstateindicatorslot="${containedStateIndicatorSlot}" containedstateindicatorstyle="${containedStateIndicatorStyle}" containedspritedepth="${containedSpriteDepth}">\n`;

            // Slot Icons - Hardcoded as per user's example
            xml += `    <SlotIcon slotindex="0" texture="Content/UI/StatusMonitorUI.png" sourcerect="256,448,64,64" origin="0.5,0.5" />\n`;
            xml += `    <SlotIcon slotindex="1" texture="Content/UI/StatusMonitorUI.png" sourcerect="320,448,64,64" origin="0.5,0.5" />\n`;
            xml += `    <SlotIcon slotindex="2" texture="%ModDir%/UI/icons.png" sourcerect="192,0,64,64" origin="0.5,0.5" />\n`;
            xml += `    <SlotIcon slotindex="3" texture="%ModDir%/UI/icons.png" sourcerect="0,64,64,64" origin="0.5,0.5" />\n`;
            xml += `    <SlotIcon slotindex="4" texture="%ModDir%/UI/icons.png" sourcerect="64,0,64,64" origin="0.5,0.5" />\n`;
            xml += `    <SlotIcon slotindex="5" texture="%ModDir%/UI/icons.png" sourcerect="128,0,64,64" origin="0.5,0.5" />\n`;

            // Main Containable
            document.querySelectorAll('#mainContainables .dynamic-item-group').forEach(group => {
                const items = group.querySelector('.containable-items').value;
                const hide = group.querySelector('.containable-hide').value;
                const itempos = group.querySelector('.containable-itempos').value;
                const rotation = group.querySelector('.containable-rotation').value;
                if (items) {
                    xml += `    <Containable items="${items}" hide="${hide}" itempos="${itempos}" rotation="${rotation}" />\n`;
                }
            });

            // SubContainers - Modified to use nested Containable tag
            document.querySelectorAll('#subContainerGroups .dynamic-item-group').forEach(group => {
                const items = group.querySelector('.sub-containable-items').value;
                const hide = group.querySelector('.sub-containable-hide').value;
                const itempos = group.querySelector('.sub-containable-itempos').value;
                const setactive = group.querySelector('.sub-containable-setactive').value;

                xml += `    <SubContainer capacity="1" maxstacksize="1">\n`; 
                xml += `      <Containable items="${items}" hide="${hide}" itempos="${itempos}" setactive="${setactive}" >\n`;
                xml += `      </Containable>\n`; // Changed to opening and closing tags
                xml += `    </SubContainer>\n`;
            });

            xml += `  </ItemContainer>\n`;

            // AI Target
            xml += `  <aitarget sightrange="${aiTargetSightRange}" soundrange="${aiTargetSoundRange}" fadeouttime="${aiTargetFadeOutTime}" />\n`;

            // Quality
            xml += `  <Quality>\n`;
            xml += `    <QualityStat stattype="${qualityStatType}" value="${qualityValue}" />\n`;
            xml += `  </Quality>\n`;

            // Skill Requirement Hint
            xml += `  <SkillRequirementHint identifier="${skillHintIdentifier}" level="${skillHintLevel}" />\n`;


            xml += `</Item>`;
            
            document.getElementById('xmlOutput').textContent = formatXml(xml);
        }

        // Helper function for XML formatting
        function formatXml(xml) {
            let formatted = '';
            const reg = /(>)(<)(\/?)/g;
            xml = xml.replace(reg, '$1\r\n$2$3');
            let pad = 0;
            xml.split('\r\n').forEach(node => {
                let indent = 0;
                if (node.match( /.+<\/\w[^>]*>$/ )) {
                    indent = 0;
                } else if (node.match( /^<\/\w/ )) {
                    pad--;
                } else if (node.match( /^<\w[^>]*[^\/]>.*$/ )) {
                    pad++;
                }
                for (let i = 0; i < pad; i++) {
                    formatted += '  '; 
                }
                formatted += node + '\r\n';
            });
            return formatted.trim();
        }
    </script>
</body>
</html>